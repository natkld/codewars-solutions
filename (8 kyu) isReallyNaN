I've hit a few bugs in my Java/Type/Coffee-script code recently, and I've traced the problem back to the global isNaN function I was using. 
I had expected it to be more discerning, but it's returning true for undefined right now.
Write a function isReallyNaN that returns true only if passed in an argument that evalutes to NaN, and returns false otherwise.
Any solution is acceptable

Недавно я обнаружил несколько ошибок в коде Java/Type/Coffee-script, и я отследил проблему до глобальной функции isNaN, которую я использовал.
Я ожидал, что он будет более проницательным, но он возвращается истинным для неопределенных прямо сейчас.
Напишите функцию isCouringNaN, которая возвращает значение true, только если она передается в аргументе, который вычисляется в NaN, и возвращает значение false в противном случае.
Любое решение приемлемо!

CODE 1:
const isReallyNaN = (val) => {
  return val !== val 
}

console.log(isReallyNaN(37) === false)
console.log(isReallyNaN('37') === false)
console.log(isReallyNaN(NaN) === true)
console.log(isReallyNaN(undefined) === false)

CODE 2:
const isReallyNaN = Number.isNaN

CODE 3:
const isReallyNaN = val => val != val

CODE 4:
isReallyNaN=_=>_=='NaN'?false:_+''=='NaN'
